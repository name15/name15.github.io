<html>
	<head>
		<title>WebGL</title>
		<style>
body {
	user-select: none;
}
#canvas{
	border: 2px solid blue;
}
#text{
	width: 300px;
}
button{
	width: 100px;
}
#error{
	background-color: red;
	color: white;
}
#click {
	position: absolute;
	display: none;
}
#click > p{
	background-color: white;
	font-variant-numeric: oldstyle-nums;
	margin-top: 5px;
	padding: 2px;
	border-radius: 2px;
	box-shadow:         2px 2px 5px 2px #ccc;
}
		</style>
	</head>
	<body>
		<input id="text"></input>
		<button onclick="build();">PLOT</button>
		<p id="error"></p>
		<canvas id="canvas" width="400" height="300"></canvas>
		<div id="click" onclick="this.style.display = 'none';">
			<svg width="6" height="6"><circle cx="3" cy="3" r="2" stroke="black" stroke-width="1" fill="white" /></svg>
			<p></p>
		</div> 
		<script id="vert" type="notjs">
// an attribute will receive data from a buffer
attribute vec4 a_position;

// all shaders have a main function
void main() {
	// gl_Position is a special variable a vertex shader
	// is responsible for setting
	gl_Position = a_position;
}
		</script>
		<script id="frag" type="notjs">
uniform vec2 u_resolution;
uniform vec2 u_mouse;
uniform vec3 u_transform;

vec4 colormap1(float o){
	if (o > 0.) return vec4(1., 1., 1., 0.);
	else return vec4(0., 0., 0., 1.);
}

float gradient = 5.;
vec4 colormap2(float o){
	float a = smoothstep(0., u_transform.z*gradient, o+u_transform.z*gradient/2.);
	return vec4(smoothstep(1., 0., a), 0., 0., a);
}

void main() {
	float minResolution = min(u_resolution.x, u_resolution.y);
	vec2 pos = (gl_FragCoord.xy/minResolution - 0.5*u_resolution/minResolution)*u_transform.z + u_transform.xy/u_resolution;
	if (floor(min(abs(pos.x), abs(pos.y))*minResolution/(u_transform.z*2.)+0.5)==0.) 
		gl_FragColor = vec4(0., 0., 1., 1.);
	
	else gl_FragColor = vec4(colormap2(function(pos.x, pos.y)));
}
		</script>
		<script>
// Get A WebGL context
const canvas = document.querySelector("#canvas"),
	textInput = document.querySelector("#text"),
	error = document.querySelector("#error"),
	click = document.querySelector("#click"),
	gl = canvas.getContext("webgl");

if (!gl) {
	throw "WebGL not supported!";
}

console.log(document.body.childNodes);

var myProgram = false;

textInput.value = "(x*x*x-4.*x)*(x*x+2.*x-8.)*(x*x+7.*x+10.)-y*50.";
//TODO: Deal with IE

var step = 25,
	moveSpeed = 10,
	scaleSpeed = 1.05;


//Update mouse - not needed in this project
/*
let mouseX = 0,
	mouseY = 0;

function setMousePosition(e) {
	const rect = canvas.getBoundingClientRect();
	mouseX = e.clientX - rect.left;
	mouseY = rect.height - (e.clientY - rect.top) - 1;	// bottom is 0 in WebGL
}

canvas.addEventListener('mousemove', setMousePosition);
canvas.addEventListener('touchstart', (e) => {
	e.preventDefault();
}, {passive: false});
canvas.addEventListener('touchmove', (e) => {
	e.preventDefault();
	setMousePosition(e.touches[0]);
}, {passive: false});
*/

function precise(x) {
  return Number.parseFloat(x).toPrecision(5);
}

//Click to show coordinates
canvas.addEventListener("click", function(e){ 
	if (myProgram) {
		let x = e.pageX-canvas.offsetLeft, y = e.pageY-canvas.offsetTop;
		
		let minResolution = Math.min(canvas.width, canvas.height);
		let newX = (x/minResolution - 0.5*canvas.width/minResolution)*scale + transformX/canvas.width,
			newY = (y/minResolution - 0.5*canvas.height/minResolution)*scale - transformY/canvas.height;
		
		click.style.top = e.pageY;
		click.style.left = e.pageX;
		click.style.display = "inline"
		click.childNodes[3].innerHTML = "x: "+precise(newX)+"<br>y: "+precise(newY);
	}
});

//Update keyboard
let transformX = 0,
	transformY = 0,
	scale = 15.;

var keyMap = [];
onkeydown = onkeyup = function(e){
	if (document.activeElement.tagName != "INPUT"){
		e = e || event; // to deal with IE
		keyMap[e.key] = (e.type == "keydown");
	} else if (e.key == "Enter") {
		build();
	}
}

function input(){
	let x = 0, y = 0, s = 0;
	
	//Transform
	if (keyMap["w"]) y++;
	if (keyMap["s"]) y--;
	if (keyMap["d"]) x++;
	if (keyMap["a"]) x--;
	//Scale
	if (keyMap["f"]) s++;
	if (keyMap["r"]) s--;
	
	transformX += x*moveSpeed*scale;
	transformY += y*moveSpeed*scale;
	scale *= Math.pow(scaleSpeed, s);
	
	if (x==0 && y==0 && s==0) return false;
	console.log(transformX+"|"+transformX+"|"+scale);
	
	click.style.display = "none"
	return true;
	
}

function createProgram(source){
	var shaders = [];
	
	//Create a program object
	var program = gl.createProgram();
	
	for (var i=0; i<2; i++){
		shaders[i] = gl.createShader(source[i].type);
		
		//Attach shader source code
		gl.shaderSource(shaders[i], source[i].glsl);
		
		//Compile the vertex shader
		gl.compileShader(shaders[i]);
		
		//Check for errors
		var success = gl.getShaderParameter(shaders[i], gl.COMPILE_STATUS);
		if (!success) {
			console.warn("Error while creating shader!");
			error.innerHTML = gl.getShaderInfoLog(shaders[i]);
			gl.deleteShader(shaders[i]);
			return false;
		}
		
		//Attach the shaders
		gl.attachShader(program, shaders[i]);
	}
	
	//Link the shaders in a program
	gl.linkProgram(program);
	
	//Check for errors
	var success = gl.getProgramParameter(program, gl.LINK_STATUS);
	if (!success) {
		console.warn("Error while creating program!");
		error.innerHTML = gl.getProgramInfoLog(program);
		gl.deleteProgram(program);
		return false;
	}
	return program;
}

var positionAttributeLocation, resolutionLocation, transformLocation, positionBuffer;

function build(){
	//gl.deleteProgram(program);

	var func = `precision highp float;
	float function(float x, float y){
	return ` + textInput.value + `;
	}`

	const vs = document.querySelector("#vert").text;
	const fs = func + document.querySelector("#frag").text;

	// setup GLSL program
	myProgram = createProgram([
		{ glsl: vs, type: gl.VERTEX_SHADER} ,
		{ glsl: fs, type: gl.FRAGMENT_SHADER}
	]);
	
	if (myProgram){

		// look up where the vertex data needs to go.
		positionAttributeLocation = gl.getAttribLocation(myProgram, "a_position");

		// look up uniform locations
		resolutionLocation = gl.getUniformLocation(myProgram, "u_resolution");
		//const mousePositionLocation = gl.getUniformLocation(myProgram, "u_mouse");
		transformLocation = gl.getUniformLocation(myProgram, "u_transform");

		// Create a buffer to put three 2d clip space points in
		positionBuffer = gl.createBuffer();

		// Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)
		gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

		// fill it with a 2 triangles that cover clipspace
		gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
			-1, -1,	// first triangle
			 1, -1,
			-1,	1,
			-1,	1,	// second triangle
			 1, -1,
			 1,	1,
		]), gl.STATIC_DRAW);
		
		render(myProgram);
		
		//Remove errors
		error.innerHTML = "";
		canvas.style.filter = "contrast(100%)";
		
	} else {
		//Add errors
		click.style.display = "none"
		canvas.style.filter = "contrast(25%)";
	}
}

function render(program) {

	// Tell WebGL how to convert from clip space to pixels
	gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);

	// Tell it to use our program (pair of shaders)
	gl.useProgram(program);

	// Turn on the attribute
	gl.enableVertexAttribArray(positionAttributeLocation);

	// Bind the position buffer.
	gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);

	// Tell the attribute how to get data out of positionBuffer (ARRAY_BUFFER)
	gl.vertexAttribPointer(
			positionAttributeLocation,
			2,			// 2 components per iteration
			gl.FLOAT,	// the data is 32bit floats
			false,		// don't normalize the data
			0,			// 0 = move forward size * sizeof(type) each iteration to get the next position
			0,			// start at the beginning of the buffer
	);

	gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);
	//gl.uniform2f(mousePositionLocation, mouseX, mouseY);
	gl.uniform3f(transformLocation, transformX, transformY, scale);

	gl.drawArrays(
			gl.TRIANGLES,
			0,		 	// offset
			6,		 	// num vertices to process
	);
}

build();



function mainloop(){
	if (myProgram) {
		if (input()) render(myProgram);
	}
}

var loopId = setInterval(mainloop, step);

</script>



</body></html>
